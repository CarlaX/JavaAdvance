# GC

## 1. SerialGC

单线程，用于年轻代和老年代，年轻代使用标记复制算法，老年代使用标记整理算法，在整个GC过程中，应用程序都处于暂停状态。堆内存划分为连续的年轻代（新生代和2*存活区）和老年代。适用于单CPU，响应速度优先的环境。

## 2. ParallelGC

多线程，用于年轻代和老年代，年轻代使用标记复制算法，老年代使用标记整理算法，整个GC过程，应用程序都处于暂停状态。堆内存划分为连续的年轻代（新生代和2*存活区）和老年代。适用于多CPU，吞吐量优先的环境。

## 3. CMSGC

多线程，用于老年代，年轻代使用ParNewGC，ParNewGC与ParallelGC工作原理基本一致，专门为CMS进行适配。老年代回收过程中可能伴随多次年轻代回收。CMS使用标记清除算法，细化多个回收阶段，将应用程序暂停占GC比例尽可能缩小（初始标记和最终标记两阶段SWT暂停）。堆内存划分为连续的年轻代（新生代和2*存活区）和老年代。适用于多CPU，响应速度优先的环境。

## 4. G1GC

多线程，用于年轻代和老年代，年轻代使用标记复制算法，老年代使用标记清除整理算法，在清理过程中进行部分整理，一定次数GC后对全内存进行整理。堆内存划分为多个region，年轻代（新生代和1*存活区）和老年代的物理空间是离散的，逻辑上连续，每块内存可以被动态划分给年轻代或者老年代，对于大对象（占用region超过50%）会在年轻代和老年代以外开辟空间存放和管理。G1回收时，使用回收集CSet进行增量回收（全部的年轻代和部分的老年代）。回收过程细化为多个阶段（初始标记和再次标记阶段SWT暂停）。G1通过RSet避免全堆扫描，G1针对每个年龄代维护多个RSet，每个小堆块对应一个RSet，包含所有从外部指向该region中对象的引用，避免全堆扫描。

- G1维护了老年代指向年轻代的指针，保存在年轻代的RSet中
- G1维护了老年代指向老年代的指针，保存在老年代的RSet中

对于年轻代指向老年代的指针，不保存在RSet中，因为年轻代回收和混合回收都会对年轻代全量回收。

region中每512字节划分为一个堆内存块，G1为每个region维护了一个全局的堆内存块表。

G1适用于多CPU，响应速度有限的环境。